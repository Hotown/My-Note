# Linux内核学习（一）—— 进程管理

## 1. 进程概述

**进程就是处于执行期的程序**。在计算机上运行的每一个应用都可以称之为进程。一个进程，不仅仅局限于一段可执行的代码段，还包括了例如打开的文件，挂起的信号，处理器状态，内存地址空间以及若干个执行线程（thread of excution）。

执行线程，是在进程中活动的对象，他另一个名字听起来更为熟悉——线程。每个线程都拥有一个独立的程序计数器，进程栈以及一组进程寄存器。**线程内核调度的基本对象。**

## 2. 进程描述符及任务结构

Linux内核把进程的列表存放在任务队列（task list）中，任务队列是一个双向循环链表，链表中每一项的类型都为task_struct，称为进程描述符（process description）。进程描述符中包含了一个具体进程的所有信息。

### 2.1 分配进程描述符

Linux通过slab分配器分配task_struct结构，只需要在栈底（对于向下增长的栈而言）或在栈顶（对于向上增长的栈而言）创建新的结构thread_info。

```
struct thread_info {
	struct task_struct	*task;		/* 指向进程描述符的指针 */
	__u32		flags;		/* low level flags */
	__u32		cpu;		/* cpu */
	int			preempt_count;	/* 0 = preemptable, <0 = BUG */
	mm_segment_t		addr_limit;	/* 线程地址空间 */
};
```
每个人物的thread_info结构在它的内核栈尾端分配。

### 2.2 进程描述符的存放

Linux内核通过唯一进程标识值或PID来标识每一个进程。pid是一个int类型的值，默认最大值为32769，可以在/proc/sys/kernel/pid_max中修改上限，pid的最大值，限制了系统中允许同时存在的进程的最大数目。

在内核中，想要访问任务需要拿到指向其的task_struct指针。在某些硬件体系结构中，可以用一个单独的寄存器来存放指向当前进程的task_struct指针，以便于快速访问。而另外的，寄存器并不富裕的体系结构，则通过创建thread_info，计算偏差值来查找task_struct结构。

### 2.3 进程状态

task_struct中用一个state域来描述当前进程的状态。这里简单介绍进程的五种状态。

+ TASK_RUNNING（运行）——说明进程是可执行的：它或者正在执行，或者在运行队列中待执行。**这是进程在用户空间中执行的唯一可能状态。**
+ TASK_INTERRUPTIBLE（可中断）——线程正在睡眠（被阻塞），等待某些条件的达成。一旦条件达成，内核就会把进程状态设置为运行。该状态可能会因为接收到信号而提前被唤醒并准备投入运行。
+ TASK_UNINTERRUPTIBLE（不可中断）——与可中断状态相比，不同点在于此状态下的进程即使收到信号也不会被唤醒。使用较少。
+ _TASK_TRACED——被其他进程追踪的进程。
+ _TASK_STOPPED（停止）——进程停止执行：进程没有投入运行也不能被投入运行。

![进程状态转化](http://ofhmxbqy4.bkt.clouddn.com/IMG_0569.JPG)

## 3. 进程创建

Unix系统中，进程的创建步骤分别在fork()和exec()中执行。fork()通过拷贝当前进程，创建一个子进程。子进程与父进程的区别在于PID（每一个进程唯一），PPID（父进程的进程号）和某些资源和统计量。exec()负责读取可执行文件，并将其载入地址空间开始运行。

### 3.1 写时拷贝

相比较传统的fork()会直接把所有的资源复制给新创建的进程，这种方法实现效率低下，且大部分情况下，子进程并不需要父进程的所有资源。更致命的在于，如果新进程打算立即执行一个新的映像，那么所有的拷贝将会前功尽弃。

Linux的fork()采用写时拷贝（copy-on-write）页实现。只有在写入的时候，数据才会被复制，使得各个进程拥有各自的拷贝。在写入之前，父进程和子进程以只读方式共享同一个拷贝。

写时拷贝推迟了地址空间中页的拷贝，甚至在某些情况下（fork()后直接exec()，不需要写入）可以完全免除复制，加快了Unix系统的执行。

### 3.2 fork()

Linux通过clone()系统实现fork()

过程：`fork()-->do_fork()-->copy_process()`

其中，copy_process完成的工作主要如下：

1. 调用dup_task_struct()为进程创建一个内核栈、thread_info结构以及task_struct，此时，子进程和父进程的进程描述符是完全相同的。
2. 检查并确认新创建这个子进程后，当前用户所拥有的进程数目没有超过给它分配的最大值。
3. 进程描述符大多数成员被清0或初始化。task_stuct中的大多数数据都已然保持不变。
4. 子进程的state被设置为TASK_UNINTERRUPTIBLE，保证它不会投入运行。
5. copy_process()调用copy_flags()来更新task_struct中的flags成员。PF_SUPERPRIV标志（表明进程拥有超级用户权限），PF_FORKNOEXEC标志（表示进程未执行exec()）被设置。
6. 调用alloc_pid()设置pid。
7. 根据传递给clone()的参数，copy_process()拷贝或共享信息。
8. 最后，copy_process()返回一个指向子进程的指针。

回到do_fork()函数，若copy_process成功返回，则新创建的子进程被唤醒并投入使用。

### 3.3 vfork()

vfork()不拷贝父进程的页表项。子进程作为父进程的一个单独线程在它的地址空间里运行，此时父进程会被阻塞，以防止父进程重写子进程需要的数据，直到子进程exec()或者退出。子进程无法向地址空间进行写入。

现在的fork()由于引入了写时拷贝页，并明确了子进程先执行，vfork()的好处便仅仅限于不拷贝父进程的页表项了。

理想情况下，系统最好不要调用vfork()，内核也不用去实现它。

## 4. 线程在Linux中的实现

线程提供了在统一程序内共享内存地址空间运行的一组线程。在Linux内核角度来说，没有线程的概念，Linux把所有的线程都当做进程来实现。每个线程都拥有唯一的task_struct。

### 4.1 创建线程

`clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE SIGHAND, 0);`

产生的结果和调用fork()类似，父子进程共享地址空间、文件系统资源、文件描述符和信号处理程序。

一个普通fork()的实现为：

`clone(SIGCHLD, 0);`

### 4.2 内核线程

内核线程（kernel thread）是独立运行在内核空间的标准进程，它和普通进程的区别在于，内核线程没有独立的地址空间（指向地址空间的mm指针被设置成NULL）。他们只在内核空间运行而不会切换到用户空间去。

## 5. 进程终结

进程的析构发生在调用exit()系统时，既可能显式调用，也可能隐式地从某个程序的主函数返回。当进程接收到它既不能处理，也不能忽略的信号时，也可能发生被动终结。

过程：`exit()-->do_exit()`

其中do_exit()完成的工作：

1. 将task_struct中的标志成员设置为PF_EXITING。
2. 调用del_timer_sync()删除任一内核定时器。根据返回结果，它确保没有定时器在排队，也没有定时器处理程序在运行。
3. 如果BSD的进程记账功能是开启的，do_exit()调用acct_update_integrals()来输出记账信息。
4. 调用exit_mm()释放进程占用的mm_struct。
5. 调用sem__exit()。
6. 调用exit_files()和exit_fs()，分别递减文件描述符、文件系统数据的引用计数。若降为0则释放。
7. 调用exit_notify()向父进程发出信号，寻找养父进程，并将进程状态设置为EXIT_ZOMBIE。
8. do_exit()调用schedule()切换到新的进程。

与进程相关的资源全部被释放后，它占用的所有内存只剩下内核栈，thread_info结构和task_struct。此时子进程存在的唯一目的是向父进程提供信息，父进程确认并通知内核这些信息无关后，剩余的内存被释放。

### 5.1 删除进程描述符

do_exit()以后，线程僵死不能再运行，但是系统会保留它的进程描述符以便为父进程提供信息。调用release_task()释放进程描述符。

### 5.2 孤儿进程

如果父进程在子进程退出之前退出，内核必须为这些子进程找到新的父亲，否则这些孤儿进程将会永远僵死，白白耗费内存。

`do_exit()-->exit_notify()-->forget_original_parent()-->find_new_reaper()`


