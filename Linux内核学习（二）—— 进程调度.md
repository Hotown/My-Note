# Linux内核学习（二）—— 进程调度

## 1. 多任务

多任务操作系统就是能同时并发地交互执行多个进程的操作系统。

多任务系统可以划分为两类：**非抢占式多任务（cooperative multitasking）**，**抢占式多任务（preemptive multitasking）**。

### 抢占

在抢占式多任务模式下， 由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会。这个强制挂起动作被称为抢占（preemption）。

### 时间片

时间片是分配给每个可运行进程的处理器时间段。有效管理时间片能够使调度程序从系统全局的角度做出调度决定，还可以避免个别进程独占系统资源。

## 2.策略

策略决定调度程序的调度方式，何时让哪个进程运行。调度器的策略往往决定了系统的整体印象。

### I/O消耗型和处理器消耗型进程

**I/O消耗型进程：** I/O消耗型进程的主要特征是，大部分时间都在等待I/O请求，运行频率高，但是运行时间短。

**处理器消耗型进程：** 处理器消耗型进程的主要特点在于，它把大部分时间花在执行代码上，除非被抢占，否则它们通常一直处于运行状态。

调度策略通常要在两个矛盾的目标中间寻找平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）。

### 进程优先级

调度算法中最基本的一类便是基于优先级的调度。这是一种根据进程的价值和其对处理器时间的需求来对进程分级的想法。通常做法为，优先级高的进程先运行，如果遇到相同优先级的进程，则按轮转方式调度。内核总是会选择时间片未用尽且优先级高的进程执行。

Linux采用两种优先级范围，一种是**nice值**的普通进程优先级，另一种是**实时优先级**。

> 任何时候，实时进程的优先级都高于普通进程。

nice值是一个-20~+19的数，默认值为0。nice值越大，意味着优先级越低（nice可以理解为好，好的进程当然需要谦让其他进程QWQ）。不同的Unix系统由于调度算法不同，nice值的含义也会有差异。在Linux系统中，nice值代表分配给进程的时间片的比例。

实时优先级是可以配置的，默认为0~99。越高的实时优先级数值意味着进程的优先级更高。

需要注意的是，实时进程只会被更高级的实施进程抢占，同级实时进程按照FIFO（一次执行完）或者RR（多次轮转）的规则调度。

## 3. 调度算法

### 调度器类

Linux调度器以模块方式提供，这样做的目的是允许不同类型的进程可以有针对性地选择调度算法。这种模块化的结构成为**调度器类（scheduler classes）**。

### 完全公平调度（CFS）

传统的Unix系统调度过程主要采用进程优先级和时间片，一般由用户指定静态优先级，加上对进程交互性的判断来生成动态优先级，然后根据动态优先级来决定进程的调度顺序以及时间片。

然而，nice值和优先级之间的关系会引起许多问题。

第一，**nice值和时间片之间的映射问题。**如果采用一一对应的关系，比如nice(0)的高优先级进程分配100ms时间片，nice(+19)的低优先级进程分配5ms时间片，如果两个进程同时处于可运行状态，那么所得的结果尚且令人满意。但是如果是两个低优先级的进程呢？每个进程都分到5ms的时间片，这就意味着在10ms之内，处理器将连续进行两次上下文切换，这对于高效率的内核显然是不合理的时间片分配。

第二，**相对nice值**的问题，同样也关系到nice值和时间片之间的映射问题。假设两个进程，nice(0)和nice(1)的时间片分别为100ms和95ms，可以发现，nice值相差1，时间片分配相差5ms。倘若另有两个进程，nice(18)和nice(19)的时间片分别为10ms和5ms，虽然时间片分配的绝对差相同，但是折算成比例关系呢，nice值为18和19的进程时间片相差整整一倍。

还有绝对时间片以及基于优先级的调度器为了优化交互任务而唤醒相关进程的问题，这里不再赘述。

#### cfs原理

cfs舍弃了传统的时间片，转而定义了一种新的模型，为cfs_rq（run queue）中的每一个进程增加了虚拟时钟，vruntime。

当一个进程执行的时候，它的vruntime将会不断增大，没有执行的进程vruntime保持不变。调度器总是选择vruntime最小的进程来执行，以实现“完全公平”。

为了区别不同优先级的进程，优先级高的进程vruntime增长的慢，以至于它可以得到更多的运行机会。

## 4. 调度的实现

### 时间记账

所有的调度器都必须对进程运行时间做记账。每当系统时钟节拍（tick）到来时，时间片都会被减少一个节拍周期，一个进程的时间片被减少到0是，它就会被另一个尚未减到0的时间片可运行进程抢占。

cfs虽然取消了时间片的概念，但仍然需要维护这种时间记账。方法是使用调度器的实体结构：

```
struct sched_entity {
	/* For load-balancing: */
	struct load_weight		load;
	struct rb_node			run_node;
	struct list_head		group_node;
	unsigned int			on_rq;

	u64				exec_start;
	u64				sum_exec_runtime;
	u64				vruntime;
	u64				prev_sum_exec_runtime;

	u64				nr_migrations;

	struct sched_statistics		statistics;
};
```

### 标准化vruntime

伴随着一个进程的不断执行，vruntime将会不断增大，最终都会面临一个问题，溢出。

为了解决这个溢出问题，cfs调度器为cfs_rq单独设置了一个vruntime（cfs_rq->min_vruntime），这个vruntime满足两个条件，1）单调递增 ，2）若满足1，则`cfs_rq->min_vruntime = min(vruntime)`，即这个队列的虚拟时钟等于队列中的最小vruntime。

选择进程时，也不再通过比较vruntime来确定，而是通过比较`vruntime-cfs_rq->min_vruntime`，这个差值一般不可能溢出，被称作标准化的虚拟时钟（normalized vruntime）。

当进程dequeue时，其`vruntime -= cfs_rq->min_vruntime`。而当它再次enqueue时，`vruntime += cfs_rq->min_vruntime`。

### 进程选择

cfs在选择执行进程时，会挑选一个vruntime最小的任务来执行，这就是cfs调度算法的核心。

cfs中使用红黑树来组织可运行的进程队列，并利用其迅速找到最小vruntime的进程。

## 5. 抢占和上下文切换

上下文切换，是指从一个可执行进程切换到另一个可执行进程，由context_switch()函数负责处理。当一个新的进程被选出来准备投入运行时，schedule()就会调用该函数。它完成了以下工作：

+ 调用switch_mm()，该函数负责把虚拟内存从上一个进程映射切换到新进程中。
+ 调用switch_to()，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态。包括保存、恢复栈信息和寄存器信息。

![](http://ofhmxbqy4.bkt.clouddn.com/IMG_0575.JPG)

### 用户抢占和内核抢占

用户抢占通常发生在：

+ 从系统调返回用户空间时。
+ 从中断处理程序返回用户空间时。

Linux支持内核抢占，它为每个thread_info引入了preempt_count计数器，该计数器的初始值为0，每当使用锁的时候数值加1，释放锁的时候数值减1。当数值为0时，内核就可以执行抢占。

内核抢占发生在：

+ 中断处理程序正在执行，且返回内核空间之前。
+ 内核代码再一次具有可抢占性的时候。
+ 如果内核中的任务显式地调用schedule()。
+ 如果内核中的任务阻塞。（同样会导致调用schedule()）

## 6. 实时调度策略

Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR。普通的、非实时的调度策略为SCHED_NORMAL。

SCHED_FIFO实现了简单的、先进先出的调度算法。它不适用时间片，SCHED_FIFO级的进程优先级高于SCHED_NORMAL，而且一旦这个进程被执行，就会一直处于执行状态，直到他受阻塞或显式地释放处理器。只有更高的SCHED_FIFO或者SCHED_RR才能抢占SCHED_FIFO任务。

SCHED_RR是带有时间片的SCHED_FIFO，这意味着，只要一个RR任务耗尽时间片时，它就无法继续执行，会在同一优先级的其他实时进程被轮流调度。

Linux还提供了软实时调度，它的含义是：内核调度进程，尽量使进程在它的限定时间到来前运行，但内核不保证总能满足这些进程的要求。

## 7. 参考博文

[linux内核cfs浅析](https://yq.aliyun.com/articles/8873)

[linux进程调度原理](http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html)

