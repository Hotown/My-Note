# Linux内核学习（四）—— 内核同步方法

## 原子操作

> 同步中的原子操作，是其他同步方法的基石。原子操作可以保证指令以原子的方式执行——执行过程不被打断。

原子操作可分为：`原子整数操作`，`64位原子操作`，`原子位操作`。

## 自旋锁

> Linux中最常见的锁是自旋锁（spin lock）。自旋锁最多只能被一个可执行线程持有。

一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋，这将会很大程度上浪费处理器时间，所以自旋锁不应该被长时间持有。自旋锁的初衷在于，在短期间内进行轻量级加锁。

## 读-写自旋锁

当某个数据结构的操作可以划分为`读/写`或者`生产者/消费者`两种类别是，读/写锁机制就会起到很大作用。

例如：对一个链表可能既要更新又要检索。当更新（写入）链表时，不能有其他的代码并发地写链表或从链表中读取数据，即**写操作要求完全互斥**。当对其检索（读取）链表时，只要其他程序不对链表进行写操作就行，多个并发的读取操作是被允许的。

`读/写自旋锁`就是为这种场景诞生的。这种自旋锁将读和写分别提供了不同的锁。一个或多个读任务可以并发地持有读锁；相反，用于写的锁最多只能被一个写任务持有。所以读/写锁又叫做共享/排斥锁，或者并发/排斥锁。

### 初始化

```
DEFINE_RWLOCK(mr_rwlock);

//读取端
read_lock(&mr_rwlock);
/* 临界区（只读）*/
read_unlock(&mr_rwlock);

//写入端
write_lock(&mr_rwlock);
/* 临界区（读写）*/
write_unlock(&mr_rwlock);
```

注意，不能将一个读锁升级成写锁：

```
read_lock(&mr_rwlock);
write_lock(&mr_rwlock);
```

这将会引起死锁现象，因为写锁会不断自旋，等待所有的读者释放锁，其中也包括它自己。如果读和写不能清晰地分开，那么应该选择使用一般的自旋锁而不是读-写自旋锁。

## 信号量

> Linux中的信号量是一种睡眠锁。如果一个任务试图获得一个不可用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。

### 信号量和自旋锁的区别

自旋锁在处理任务等待时，会采用自循环的方式，即不断检查临界区是否被占用。信号量在处理任务等待时，是采用睡眠的方式，当任务退出临界区后，会通知等待队列中的任务，将其唤醒。

相比于自旋锁，任务量提供了更好的处理器利用率，不必花时间在忙等待上，但是相对而言，信号量比自旋锁有更大的开销。

### 信号量的睡眠特性

+ 争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。
+ 锁被短时间占用时，使用信号量不太适宜。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁被占用的全部时间还长。
+ 由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下文中是不能进行调度的。
+ 可以在持有信号量时睡眠，此时其他试图获得信号量的进程不会因此而死锁，而是同样进入等待队列睡眠。
+ 占用信号量的同时不能占用自旋锁

### 计数信号量和二值信号量

信号量可以允许任意数量的锁持有者，而自旋锁在一个时刻只允许一个任务持有它。

信号量同时允许的持有者数量可以在声明信号量时指定。这个值称为`使用者数量`（usage count），或称为`数量`（count）。

通常情况下，一个信号量只允许一个锁持有者，这时计数等于1，这种信号量称为`二值信号量`，也叫做`互斥信号量`。当数量为大于1的非0值，这种信号量称为`计数信号量`（counting semaphore）。

信号量支持两个原子操作P()和V()，前者叫做测试操作（探查），后者叫做增加操作。后来的系统把这两种操作分别叫做down()和up()。

down()操作通过对信号量计数减1来请求获得一个信号量。如果结果是0或者大于0，获得信号量锁，任务就可以进入临界区。如果结果是负数，任务会被放入等待队列。

up()操作提升信号量。如果在该信号量上的等待队列不为空，那么处于队列中等待的任务在被唤醒的同时会获得该信号量。

### 创建和初始化

#### 静态声明信号量：

```
struct semaphore name;  //信号量的变量名
sema_init(&name, count);    //信号量的使用数量
```

创建互斥信号量：

```
static DECLARE_MUTEX(name)
```

#### 作为大数据结构部分

信号量作为一个大数据结构的一部分动态创建。此时，需要指向该动态创建的信号量的间接指针。

```
sema_init(sem, count);  //sem是指针
```

初始化一个动态穿件的互斥信号量：

```
init_MUTEX(sem);
```

### 使用信号量

+ down_interruptible()：获取指定的信号量，如果信号量不可用，它将调用进程置成TASK_INTERRUPTIBLE。
+ down_trylock()：尝试以堵塞方式来获取指定的信号量。在信号量已被占用时，它立刻返回非0值，否则返回0，而且让你成功持有信号量锁。
    
    ```
    /* 定义并声明一个信号量 */
    static DELCARE_MUTEX(mr_sem);
    
    /* 试图获取信号量 */
    if (down_interruptible(&mr_sem)) {
        /* 信号被接受，信号量还未获取 */
    }
    
    /* 临界区 */
    
    /* 释放给定的信号量 */
    up(&mr_sem); 
    ```
    
## 读-写信号量

和读-写自旋锁的作用类似，定义了一种读写锁分离的信号量。

```
static DELCARE_RWSEM(name);
```

动态创建读-写信号量

```
init_rwsem(struct rw_semaphore *sem);
```

所有的读写信号量都是互斥信号量。它们对写者互斥，而不对读者。所有读写锁的睡眠都不会被信号打断。

```
static DECLEARE_RWSEM(mr_rwsem);

/* 试图获取信号量用于读··· */
down_read(&mr_rwsem);

/* 临界区（只读）··· */

/* 释放信号量 */
up_read(&mr_rwsem);
/* ··· */

/* 试图获取信号量用于写··· */
down_write(&mr_rwsem);

/* 临界区（读和写）··· */

/* 释放信号量 */
up_write(&mr_rwsem);
```

## 互斥体

从信号量的学习中，我们发现了信号量的真相——允许睡眠的自旋锁。信号量的通用性使得信号量适合用于那些较为复杂的，未明情况下的互斥访问。

为了解决这个问题，内核开发者引入了`互斥体`(mutex)，用来取代信号量在简单的场景下使用。

mutex在内核中对应数据结构mutex，其行为和使用计数为1的信号量类似，但操作接口简单，实现高效，而且使用限制更强。

静态定义：

```
DEFINE_MUTEX(name);
```

动态初始化：

```
mutex_init(&mutex);
```

锁定和解锁：

```
mutex_lock(&mutex);
/* 临界区 */
mutex_unlock(&mutex);
```

需要注意的是：

+ mutex的计数永远是1。
+ mutex只允许在同一上下文中锁定和解锁，也就是给mutex上锁者必须负责给其解锁。
+ 不允许递归的上锁和解锁。
+ 持有mutex是，进程不可以退出。
+ 不允许在中断或者下半部中使用mutex。 

### 自旋锁和互斥体（或信号量）

![](http://ofhmxbqy4.bkt.clouddn.com/img-0595-jpg(2017-08-09T15:11:55+08:00).JPG)









