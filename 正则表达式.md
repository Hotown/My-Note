# 正则表达式

## 元字符

+ `\b`：单词的开头或结尾
+ `.`：匹配一个除换行符外的任意字符
+ `*`：前面的内容可以连续重复使用任意次（包括0）

> 例：`\bhi\b.*\bLucy\b`的意思就很明显了：先是一个单词hi,然后是任意个任意字符(但不能是换行)，最后是Lucy这个单词

+ `\d`：匹配一个数字

> 例：`0\d\d-\d\d\d\d\d\d\d\d`匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字

优质写法：`0\d{2}-\d{8}`

### 常用的元字符

代码 | 说明
--- | ---
.  | 匹配除换行符以外的任意字符
\w | 匹配字母或数字或下划线或汉字
\s | 匹配任意的空白符
\d | 匹配数字
\b | 匹配单词的开始或结束
^  | 匹配字符串的开始
$  | 匹配字符串的结束

举例：`^\d{5,12}$`：匹配5~12位数字

## 重复

### 常用的限定符

代码/语法 | 说明
--- | ----
* | 重复零次或更多次
+ | 重复一次或更多次
? | 重复零次或一次
{n} | 重复n次
{n,} | 重复n次或更多次
{n,m} | 重复n到m次

## 字符类

`[]`：写在括号内的字符匹配。

> 例：`\(?0\d{2}[) -]?\d{8}`:可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等

## 分枝条件

正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用`|`把不同的规则分隔开。

值得注意的是：**使用分枝条件时，要注意各个条件的顺序**，匹配分枝条件时，将会从做到右地测试每个条件，如果满足了某个分枝的话，就不再管其他条件。


## 分组

用小括号来指定**子表达式**（也叫**分组**），然后可以指定这个子表达式的重复次数。

`(\d{1,3}\.){3}\d{1,3}`是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：`\d{1,3`}匹配1到3位的数字，`(\d{1,3}\.){3}`匹配三次之前的数字串，加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字`(\d{1,3})`。

当然仔细一想会发现，它也将匹配类似于**256.300.899.999**这种不可能存在的IP地址。

给出一个正确的IP地址：`((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)`

具体的怎么理解，就不再赘述了。

## 反义

有时需要查找不属于某个能简单定义的字符类的字符。

### 常用的反义代码

代码/语法 | 说明
--- | ---
\W | 匹配任意不是字母，数字，下划线，汉字的字符
\S	| 匹配任意不是空白符的字符
\D	| 匹配任意非数字的字符
\B	| 匹配不是单词开头或结束的位置
[^ x] | 匹配除了x以外的任意字符
[^ aeiou] | 匹配除了aeiou这几个字母以外的任意字符

## 后向引用

当用小括号指定一个分组后，此分组捕获的内容可以在之后的程序中进一步处理。默认情况下，每个分组会自动拥有一个组号。规则是：从左向右，以分组的左括号作为标志，第一个出现的分组为1，以此类推。

`后向引用`用于重复搜索前面某个分组匹配的文本。例如，`\1`代表分组1匹配的文本。

> 例：`\b(\w+)\b\s+\1\b`可以用来匹配重复的单词，像go go, 或者kitty kitty。

你也可以自己指定子表达式的组名。要指定一个子表达式的组名，请使用这样的语法：`(?<Word>\w+)`(或者把尖括号换成'也行：`(?'Word'\w+)`),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用`\k<Word>`,所以上一个例子也可以写成这样：`\b(?<Word>\w+)\b\s+\k<Word>\b`。

### 常用的分组语法

分类 | 代码/语法 | 说明
--- | --- | ---
捕获 | (exp) | 匹配exp,并捕获文本到自动命名的组里
 |(?<name>exp) | 匹配exp,并捕获文本到名称为name的组里，也可以写成(?'name'exp)
 | (?:exp) | 匹配exp,不捕获匹配的文本，也不给此分组分配组号
零宽断言 | (?=exp) | 匹配exp前面的位置
 | (?<=exp) | 匹配exp后面的位置
 | (?!exp) | 匹配后面跟的不是exp的位置
 | (?<!exp) | 匹配前面不是exp的位置
注释 | (?#comment) | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释

## 零宽断言

接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像`\b`,`^`,`$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为**零宽断言**。

+ `(?=exp)`也叫**零宽度正预测先行断言**，它 _断言自身出现的位置的后面能匹配表达式exp_ 。比如`\b\w+(?=ing\b)`，能够匹配所有带ing的单次的前面部分，如singing中的 _sing_ ，dancing中的 _danc_ 。

+ `(?<=exp)`也叫**零宽度正回顾后发断言**，它 _断言自身出现的位置的前面能匹配表达式exp_ 。

例如：`(?<=\s)\d+(?=\s)`匹配 以空白符间隔的数字（不包括这些空白符）。

## 负向零宽断言

**零宽断言**的意义在于，它可以不消费任何字符进行位置匹配。而其他匹配符，比如`[^u]`，必定会消费一个字符进行匹配，这就会导致一系列的问题。

比如，`\b\w*q[^u]\w*\b`匹配包含后面不是字母u的字母q的单词。但是它能够匹配类似**Iraq fighting**这样的字符串。原因就在于，`[^u]`将会匹配掉q之后的分隔符。

这样一来，零宽断言的使用场景也就明确了。接下来看一下负向零宽断言的种类。

+ **零宽度负预测先行断言（?!exp）**， _断言此位置的后面不能匹配表达式exp_ 。例如：`\d{3}(?!\d)`匹配三位数字，且这三位数字的后面不能是数字。

+ **零宽度负回顾后发断言（?<!exp）**， _断言此位置的前面不能匹配表达式exp_ 。例如：`(?<![a-z])\d{7}`匹配前面不是小写字母的7位数字。

自行理解一下`(?<=<(\w+)>).*(?=<\/\1>)`，它将会匹配 _不包含属性的简单HTML标签内里的内容_ 。

> 解答：<font color=white size=4>(?<=<(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。</font>

</b>

## 懒惰与贪婪

当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：`a.*b`，它将会匹配 _最长的以a开始，以b结束的字符串_ 。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为**贪婪匹配**。

有时，我们更需要**懒惰匹配**，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样 `.*?` 就意味着匹配 _任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复_ 。现在看看懒惰版的例子吧：

`a.*?b`匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

### 懒惰限定符

代码/语法 | 说明
--- | ---
*?	| 重复任意次，但尽可能少重复
+?	| 重复1次或更多次，但尽可能少重复
??	| 重复0次或1次，但尽可能少重复
{n,m}? | 重复n到m次，但尽可能少重复
{n,}?	| 重复n次以上，但尽可能少重复


## 处理选项

### 常用的处理选项

名称 | 说明
--- | ---
IgnoreCase(忽略大小写) | 匹配时不区分大小写。
Multiline(多行模式) | 更改`^`和`$`的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,`$`的精确含意是:匹配`\n`之前的位置以及字符串结束前的位置.)
Singleline(单行模式) | 更改`.`的含义，使它与每一个字符匹配（包括换行符`\n`）。
IgnorePatternWhitespace(忽略空白) | 	忽略表达式中的非转义空白并启用由`#`标记的注释。
ExplicitCapture(显式捕获) | 仅捕获已被显式命名的组。

问：是不是只能使用多行模式和单行模式中的一种？答：当然不是，它们只是名字相似而已。


## 平衡组/递归匹配

当我们在匹配可嵌套的层次性结结构，类似于`(100 * (50 + 15))`时，会用到**平衡组**的语法构造。

+ `(?'group')`：把捕获的内容命名为group，并压入**堆栈（Stack）**。
+ `(?'-group')`：从堆栈上演出最后压入堆栈的名为group的部或内容，如果堆栈本来为空，则本分组的匹配失败。
+ `(?(group)yes|no)`：如果堆栈上存在以名为group捕获的内容的话，继续匹配yes部分的表达式，否则继续匹配no部分。
+ `(?!)`：零宽负向先行断言，由于没有后缀表达式，试图匹配总是失败

接下来我们就来分析一下，如何匹配`xx < aa <bbb> <bbb> aa > yy`这样的字符串。

我们的做法是，遇到左括号就压入一个“Open”，碰到一个右括号，就弹出一个，到最后看堆栈是否为空。若不为空，就说明左括号比右括号多，就匹配失败。

    <                       # 最外层的左括号
        [^<>]*              # 最外层的左括号后面的不是括号的内容
        (
            (
                (?'Open'<)  # 碰到左括号，在堆栈中压入一个'Open'
                [^<>]*      # 匹配左括号后面的不是括号的内容
            )+
            (
                (?'-Open'>) # 碰到右括号，弹出一个'Open'
                [^<>]+      # 匹配右括号后面的不是括号的内容
            )+
        )*
        (?(Open)(?!))       # 在遇到最外层的右括号前面，判断堆栈内还有没有'Open'，如果有，则匹配失败
    >                       # 最外层的右括号

平衡组的一个最常见的应用就是匹配HTML,下面这个例子可以匹配嵌套的`<div>`标签：`<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>`

## 参考博文

[《正则表达式30分钟入门教程》—— deerchao
](http://www.cnblogs.com/deerchao/archive/2006/08/24/zhengzhe30fengzhongjiaocheng.html)

