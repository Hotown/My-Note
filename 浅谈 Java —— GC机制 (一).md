# 浅谈 Java —— GC机制 (一)

## 概述

GC是JVM自带的垃圾清理机制，它能够自动回收对象，清理内存。与C/C++这类手动管理内存的语言相比，这无疑是Java的一大优势。

我们从以下几个方面，来探讨一下Java的GC机制。

+ Java内存模型

+ GC机制
    - What?
    - When?
    - How?

---

## 一、Java内存模型


![Java内存模型](http://ofhmxbqy4.bkt.clouddn.com/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg)

> 方法区和堆是线程共享的；程序计数器、本地方法栈和虚拟机栈是线程私有的。

1. 堆：JVM的堆区是JVM内存管理中最大的一块，也是之后所讲到的GC机制最主要的作用区域。堆区的主要作用是存储对象实例，基本上所有的对象都在堆区上分配内存。

2. 方法区：方法区又被称为静态区，存放所有的静态变量，final变量和class。

3. 虚拟机栈：在Java中，线程的每个方法在执行的同时都会创建一个栈桢，栈桢中存储有局部变量表，操作站，动态链接，方法出口灯。方法被调用时，栈桢在JVM栈中入栈，方法执行结束时，栈桢出栈。

4. 本地方法栈：本地方法栈与虚拟机栈作用相似。区别在于，JVM栈
   为Java方法服务，而本地方法栈为native方法服务。
   
5. 程序计数器：记录正在执行的虚拟机字节指令地址。如果执行的本地方法，则程序计数器为Undefined，因为只保存当前指令的地址，所以不会存在内存溢出的问题，也是唯一一个没有定义OOM的区域。

---

## GC机制

### What？

首先我们来谈论一下，什么是GC。

GC(Garbage Collection)是Java中的垃圾回收器。

在开发过程中，分配对象用new关键字，为对象申请一块内存。当我们不需要这个对象，需要将其释放时，只需要将对象所有引用赋值为null，此时，我们称这个对象为“不可到达”状态，GC便是用来回收“不可达”对象内存空间的工具。

### When？

第二个问题，GC会在什么时候工作？也就是说，GC如何去判断一个内存需要被回收呢？

**引用计数法**

引用计数法，就是每个对象都有一个引用计数器，当该对象被引用的时候计数器加1，引用失效时计数器减1。当一个对象的引用数为0时，GC会将其回收。

缺点：两个对象之间存在循环引用，就会出现“对象应该被回收，但引用计数却不为零”的情况。

**可达性分析算法**

![可达性分析算法](http://ofhmxbqy4.bkt.clouddn.com/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95.png)

它依据的思想是：对任何一个“活”的对象，一定能最终追溯到其存货在堆栈或静态存储区之中的引用。这个引用链条可能会穿过无数个对象层次。由此，如果从堆栈和静态存储区的引用开始，遍历所有的引用，就能找到所有“活”的对象。对于发现的每个引用，必须追踪它所引用的对象，然后是此对象包含的所有引用，如此反复进行，直到“根源于堆栈和静态存储区的引用”所形成的网络全部被访问为止。

**如何来定义GC Root ?**

+ 虚拟机栈（栈桢中的本地变量表）引用的对象
+ 方法区中类静态变量引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈JNI引用的变量

### How?

当GC找到了应该清理的内存空间，它如何工作呢？

#### 标记清除法

“标记-清除法”（mark-sweep）是最基础的回收算法。顾名思义，算法分为两部分，**标记**和**清除**：首先，GC扫描所有的堆空间，找出所有需要被回收的对象，然后再一次扫描，统一回收被标记的对象。

**缺点**

+ 效率低

+ 当对象被回收后，剩下的内存空间可能不是连续的，即产生大量的不连续碎片。那么下一次，需要一个较大空间时，由于找不到足够的连续内存，GC不得不被再一次启动。

#### 复制法

“复制”（Copying）法是为了解决“标记-清除”法效率不高的问题而发明的。它将内存按容量等分成两块，每次只使用其中的一块。当这块内存被使用完，就将存活的对象全部移到另一块内存（保留区）上，然后将已使用的这块内存一次全部清理。

![复制法](http://ofhmxbqy4.bkt.clouddn.com/%E5%A4%8D%E5%88%B6%E6%B3%95.png)


**缺点**

+ 内存利用率低，因为每次都要把内存等分。
 
+ 当对象存活率高时，复制操作效率很低。

#### 标记-整理法

与“标记-清理”法相反，“标记-整理”法适用于对象存活率高的情况。将存活的对象都往内存的一边移动，然后清理掉端边界以外的内存。

![标记-整理法](http://ofhmxbqy4.bkt.clouddn.com/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E6%B3%95.png)
#### 分代收集法

HotSpot将对象分为，新生代（Young Generation），年老代（Old Generation），永生代（Permanent Generation，方法去）。

**新生代（Young Generation）**

年轻代又可以细分为：`Eden`区、`Survivor` 区（`From`区、`To`区）默认比例：Eden：from：To = 8:1:1。当我们创建一个对象时，JVM首先将对象分配在`Eden`区，其中大部分对象在该区域死亡，成为垃圾对象。当`Eden`区内存空间不足，年轻代将执行Young GC回收垃圾对象，在此阶段，年轻代利用`Survivor`区GC复制算法来收集垃圾。经过几次Young GC 仍然存活的对象，将根据相关策略晋升至年老代。

**年老代（Old Generation）**

对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行 Full GC。如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。　

即，新生代，存活的对象数少于死亡的对象数，用复制法；年老代存活对象多于死亡对象，用标记-清除法。

